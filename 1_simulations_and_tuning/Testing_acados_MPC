import numpy as np
from acados_template import AcadosOcp, AcadosOcpSolver, AcadosSimSolver
from acados_template import AcadosModel
from casadi import SX, vertcat
from matplotlib import pyplot as plt

# 1. Define the system model
def export_single_integrator_model():
    model_name = "single_integrator"

    # States & controls
    x = SX.sym('x')  # state (position)
    u = SX.sym('u')  # control input (velocity)

    p = SX.sym('x_ref')  # reference for the state

    # Dynamics (discrete-time)
    f_expl = vertcat(u)  # continuous-time dynamics

    model = AcadosModel()
    model.f_expl_expr = f_expl
    model.x = x
    model.u = u
    model.name = model_name

    # Set parameters
    model.p = p

    return model

# 2. Define the MPC solver
def setup_mpc_solver(Tf, N):
    # Create ocp object
    ocp = AcadosOcp()

    # Export model
    model = export_single_integrator_model()

    # Set model
    ocp.model = model

    # Set dimensions
    nx = 1  # state dimension
    nu = 1  # input dimension
    npar = 1  # number of parameters
    #ny = nx + nu  # number of outputs in cost function

    # Set prediction horizon
    ocp.dims.N = N

    # 1. Set cost function
    Q_mat = 100 * np.eye(nx)  # State weight
    R_mat = 1 * np.eye(nu)   # Control weight

    # The 'EXTERNAL' cost type can be used to define general cost terms
    # We'll modify the cost to account for stage-wise references
    ocp.cost.cost_type = 'EXTERNAL'
    ocp.cost.cost_type_e = 'EXTERNAL'

    # External cost expressions
    x_ref = model.p[0]  # reference for the state
    #u_ref = SX(0)  # Control reference is fixed at 0

    # Stage cost and terminal cost (adjust for stage-wise references)
    ocp.model.cost_expr_ext_cost = (model.x - x_ref).T @ Q_mat @ (model.x - x_ref) + model.u.T @ R_mat @ model.u
    ocp.model.cost_expr_ext_cost_e = (model.x - x_ref).T @ Q_mat @ (model.x - x_ref)

    # 2. Set constraints
    # Input limits
    u_max = 1.0
    u_min = -1.0
    ocp.constraints.constr_type = 'BGH'
    ocp.constraints.lbu = np.array([u_min])
    ocp.constraints.ubu = np.array([u_max])
    ocp.constraints.idxbu = np.array([0])

    # Initial state constraint
    ocp.constraints.x0 = np.array([0.0])  # Starting from position 0

    # 3. Set solver options
    ocp.solver_options.qp_solver = 'FULL_CONDENSING_QPOASES'
    ocp.solver_options.hessian_approx = 'GAUSS_NEWTON'
    ocp.solver_options.integrator_type = 'ERK'
    ocp.solver_options.nlp_solver_type = 'SQP'
    ocp.solver_options.tf = Tf

    # Initialize parameters with default values (this step is important to avoid dimension mismatch)
    ocp.parameter_values = np.zeros(npar)

    # Create solver
    acados_ocp_solver = AcadosOcpSolver(ocp, json_file="acados_ocp.json")

    return acados_ocp_solver

# 6. Main MPC loop
def run_mpc(Tf,N,Nsim,x_ref,x_init):

    # Setup solver
    solver = setup_mpc_solver(Tf, N)

    # Simulate system for multiple steps
    x_vec = np.zeros(Nsim)
    x_current = x_init


    for i in range(Nsim):
        
        # Set stage-wise references
        for k in range(N):
            params = x_ref[i+k]  # Stage-wise references
            solver.set(k, 'p', params)

        # store new value
        x_vec[i] = x_current[0]

        solver.set(0, "lbx", x_current)
        solver.set(0, "ubx", x_current)

        # Solve MPC problem
        status = solver.solve()
        if status != 0:
            print(f"MPC Solver failed at step {i} with status {status}.")
            break

        # Get optimal control input
        u0 = solver.get(0, "u")
        #print(f"Step {i}: x = {x_current}, u = {u0}")

        # Simulate system forward
        x_current = x_current + Tf / N * u0


    #solver.store_iterate("solver_iterate.json") # no need to store results
    return x_vec



# Run MPC
Tf = 1.0  # Time horizon
N = 20  # Number of steps in the horizon
dt = 0.1 # Time step [s]
t_sim = 10.0  # Simulation time [s]
Nsim = int(t_sim / dt)  # Number of simulation steps

# produce time-varying reference
t_vec = np.linspace(0,dt * Nsim, Nsim)
t_vec_reference = np.linspace(0,dt * (Nsim+N), Nsim+N)
freq = 0.1 # [Hz]
amplitude = 0.5
x_ref = amplitude * np.sin(freq * 2*np.pi*t_vec_reference)  # Stage-wise references (make sure it's N steps longer than t_vec to not run out)

x_init = np.array([-0.25])  # Initial state
# run MPC simulation loop
x_vec = run_mpc(Tf,N,Nsim,x_ref,x_init)

# plot results
plt.figure()
plt.plot(t_vec,x_vec,label="x",color = 'dodgerblue')
plt.plot(t_vec_reference,x_ref,label="reference",color = 'gray',linestyle='--')
plt.legend()
plt.show()
